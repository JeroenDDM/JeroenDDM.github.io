'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parseUrl = require('url-parse');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var parseUrl__default = /*#__PURE__*/_interopDefaultLegacy(parseUrl);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function assert(value, msg) {
    if (!value)
        throw new Error(msg);
}
function assertValidStringArray(value, valueName) {
    if (valueName === void 0) { valueName = 'value'; }
    assert(value instanceof Array, "".concat(valueName, " must be an array of strings"));
    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
        var name_1 = value_1[_i];
        assert(typeof name_1 === "string", "Each item in ".concat(valueName, " must be a string"));
    }
}
function parseValidUrl(value) {
    assert(typeof value === "string", "url is not a string");
    // Explicitly pass {} as 2nd param so that `url-parse` parses the url
    // independently from the browser's current window location
    var url = parseUrl__default['default'](value, {});
    assert(url.protocol && url.hostname, "invalid url: '".concat(value, "', unable to parse hostname"));
    return url;
}
function assertValidEnvFilters(value) {
    assert(!!value && typeof value === "object", "Provided filters must be an object");
    var filters = value;
    if (filters.env !== undefined) {
        assert(filters.env instanceof Array, 'filters.env must be an array');
        assert(filters.env.every(function (env) { return ENVS.indexOf(env) >= 0; }), "'".concat(filters.env, "' - filters.env must be an array containing only: ").concat(ENVS.join(',')));
    }
    if (filters.status !== undefined) {
        assert(filters.status instanceof Array, 'filters.status must be an array');
        assert(filters.status.every(function (status) { return STATUSES.indexOf(status) >= 0; }), "'".concat(filters.status, "' - filters.status must be an array containing only: ").concat(STATUSES.join(',')));
    }
}

var _environments = [
	{
		name: "fedramp-use2-core",
		env: "fedramp",
		region: "us-east-2",
		status: "stable",
		publicDomainName: "use2.us-gov-pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod",
		env: "prod",
		region: "us-east-1",
		status: "stable",
		publicDomainName: "mypurecloud.com",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-apne1",
		env: "prod",
		region: "ap-northeast-1",
		status: "stable",
		publicDomainName: "mypurecloud.jp",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-apne2",
		env: "prod",
		region: "ap-northeast-2",
		status: "stable",
		publicDomainName: "apne2.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-apne3",
		env: "prod",
		region: "ap-northeast-3",
		status: "stable",
		publicDomainName: "apne3.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-aps1",
		env: "prod",
		region: "ap-south-1",
		status: "stable",
		publicDomainName: "aps1.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-apse2",
		env: "prod",
		region: "ap-southeast-2",
		status: "stable",
		publicDomainName: "mypurecloud.com.au",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-cac1",
		env: "prod",
		region: "ca-central-1",
		status: "stable",
		publicDomainName: "cac1.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-euc1",
		env: "prod",
		region: "eu-central-1",
		status: "stable",
		publicDomainName: "mypurecloud.de",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-euc2",
		env: "prod",
		region: "eu-central-2",
		status: "stable",
		publicDomainName: "euc2.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-euw1",
		env: "prod",
		region: "eu-west-1",
		status: "stable",
		publicDomainName: "mypurecloud.ie",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-euw2",
		env: "prod",
		region: "eu-west-2",
		status: "stable",
		publicDomainName: "euw2.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-mec1",
		env: "prod",
		region: "me-central-1",
		status: "stable",
		publicDomainName: "mec1.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-sae1",
		env: "prod",
		region: "sa-east-1",
		status: "stable",
		publicDomainName: "sae1.pure.cloud",
		publicDomainAliases: [
		]
	},
	{
		name: "prod-usw2",
		env: "prod",
		region: "us-west-2",
		status: "stable",
		publicDomainName: "usw2.pure.cloud",
		publicDomainAliases: [
		]
	}
];

var environments = _environments;
var ENVS = ["dev", "test", "prod", "fedramp"];
var STATUSES = ["alpha", "beta", "stable", "archived"];
var DEFAULT_LOCAL_HOSTNAMES = ["localhost", "127.0.0.1"];
var STABLE_PUBLIC_ENVS_FILTERS = { env: ["prod", "fedramp"], status: ["stable"] };
var NO_FILTERS = {};
var endsWith = function (s1, s2) {
    return s1.slice(s1.length - s2.length) === s2;
};
var matchesHostname = function (hostname) { return function (domain) {
    return hostname === domain || endsWith(hostname, ".".concat(domain));
}; };
/**
 * Retrieves the list of Genesys Cloud environment/region deployments.
 * Defaults to only returning stable, publically available deployments (e.g. prod, fedramp)
 */
var getEnvironments = function (filters) {
    if (filters === void 0) { filters = STABLE_PUBLIC_ENVS_FILTERS; }
    assertValidEnvFilters(filters);
    var env = filters.env, status = filters.status;
    return environments
        .filter(function (data) { return env === undefined || env.indexOf(data.env) >= 0; })
        .filter(function (data) { return status === undefined || status.indexOf(data.status) >= 0; });
};
/**
 * Whether or not the given url is a known Genesys Cloud deployment.  If no filters
 * are provided, the default behavior is to only check stable, publically available deployments
 * (e.g. prod, fedramp).
 *
 * - throws an error if passed an invalid url
 * - returns false for localhost
 */
var isKnown = function (url, filters) { return !!parse(url, filters); };
/**
 * Retrieve the Genesys Cloud `Environment` for a given url.  If no filters
 * are provided, the default behavior is to only check stable, publically available deployments
 * (e.g. prod, fedramp).
 *
 * - throws an error if passed an invalid url
 * - returns undefined if no match is found
 */
var parse = function (url, filters) {
    var hostname = parseValidUrl(url).hostname;
    return getEnvironments(filters).find(function (_a) {
        var publicDomainName = _a.publicDomainName, publicDomainAliases = _a.publicDomainAliases;
        var domains = __spreadArray([publicDomainName], publicDomainAliases, true).filter(function (d) { return !!d; });
        return domains.some(matchesHostname(hostname));
    });
};
/**
 * Retrieve the current Genesys Cloud runtime environment for the given url.
 * This method attempts to parse the hostname directly (uses `parse` under the hood).
 *
 * By default, this method will attempt to search across all available environments (no filtering).
 */
var parseDeployedRuntime = function (url, filters) {
    if (url === void 0) { url = window.location.href; }
    if (filters === void 0) { filters = NO_FILTERS; }
    assertValidEnvFilters(filters);
    var hostname = parseValidUrl(url).hostname;
    var parsedEnv = parse(url, filters);
    if (!parsedEnv)
        return;
    return __assign(__assign({}, parsedEnv), { local: false, currentDomainName: __spreadArray([
            parsedEnv.publicDomainName
        ], parsedEnv.publicDomainAliases, true).filter(function (d) { return !!d; }).find(matchesHostname(hostname)) });
};
/**
 * When the hostname matches a valid local hostname, either by matching our defaults or your custom list
 * passed in the options, this method will attempt to match the first path param by name to an environment.
 * The list of environment names can be retrieved by calling `getEnvironments` and can be found under the
 * `name` key.
 *
 * By default, this method will attempt to search across all available environments (no filtering).
 *
 * Note: `currentDomainName` will be equal to `publicDomainName` when using this method.
 * Example: https://localhost:3000/prod => us-east-1 prod environment & runtime details
 */
var parseRuntimeFromLocalPath = function (localHostnames) {
    if (localHostnames === void 0) { localHostnames = DEFAULT_LOCAL_HOSTNAMES; }
    return function (url, filters) {
        if (url === void 0) { url = window.location.href; }
        if (filters === void 0) { filters = NO_FILTERS; }
        assertValidEnvFilters(filters);
        assertValidStringArray(localHostnames, 'localHostnames');
        var _a = parseValidUrl(url), hostname = _a.hostname, pathname = _a.pathname;
        if (localHostnames.indexOf(hostname) >= 0) {
            var _b = pathname.split("/"), envName_1 = _b[1];
            var localEnv = getEnvironments(filters).find(function (e) { return e.name === envName_1; });
            if (!localEnv)
                return;
            return __assign(__assign({}, localEnv), { local: true, currentDomainName: localEnv.publicDomainName });
        }
    };
};
/**
 * This is the default and recommended `RuntimeParser` implementation that is composed of the
 * `parseDeployedRuntime` and `parseRuntimeFromLocalPath` parsers. You might opt to compose the
 * `parseDeployedRuntime` with your own `RuntimeParser` as an alternative to parseRuntimeFromLocalPath.
 * You may also opt to use "parse" and `getEnvironments` together to create your own parsing strategy.
 */
var parseRuntime = function (url, filters) {
    if (url === void 0) { url = window.location.href; }
    if (filters === void 0) { filters = NO_FILTERS; }
    return parseRuntimeFromLocalPath()(url, filters) || parseDeployedRuntime(url, filters);
};

exports.ENVS = ENVS;
exports.STATUSES = STATUSES;
exports.getEnvironments = getEnvironments;
exports.isKnown = isKnown;
exports.parse = parse;
exports.parseDeployedRuntime = parseDeployedRuntime;
exports.parseRuntime = parseRuntime;
exports.parseRuntimeFromLocalPath = parseRuntimeFromLocalPath;
